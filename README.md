# Shortest Flight Paths

This is my final project for Data Structures. In this project I will find the shortest flight paths based on distance from between any US capital cities.
The overall Data Structure for this project will be a fully-connected, undirected Graph. The Graph's vertices will store data such as the city's name, its latitudinal and longitudinal coordinates, its distance in the graph from the source node, and the parent node. The Graph's edges will store data such as the nodes at each end, and its weight. 

In order to determine the shortest flight paths, I will use an adaptation of Dijkstra's algorithm. The weights of each edge will be dynamically generated while reading in a txt file with the city data and their coordinates. In order to determine the weight, I will first use the haversine formula given by: $$\mathrm{hav}(\theta)=\mathrm{hav}(\Delta\phi)+\cos(\phi_{1})\cos(\phi_{2})\mathrm{hav}(\Delta\lambda)$$ and then to determine the distance in miles, I will use the inverse haversine formula given by: 
$$d = 2r \arcsin\left( \sqrt{ \mathrm{hav}(\theta) } \right)$$
where r is going to be the average earth radius in miles: 3963.1. The algorithm works by finding all possible paths from the source node to the destination node, and returns the shortest path. This is done by updating the nodes distances from the starting node at each iteration based on the condition that if a new path is less than the previous distance to that node, then it updates that nodes distance to include the new path distance. 

## Drawbacks and Limitations

Some drawbacks for this model are that for the most part, since we are only looking at cities within the US, the shortest flight path is just a direct flight. However, If I were to include more data such as countries and major cities within those countries, then it is very likely that we will find some path that would be shorter to travel through some intermediate location before arriving at the Destination. Another thing to consider is for it to truely mimic flight paths that planes take, then I would need to encode more parameters such as how far a plane can travel on a full tank, compliance with airtraffic laws in certain contries, etc. Another Drawback is that I am using the haversine formula which is a good approximation for the Earth, however the Earth is not a perfect sphere, for which the haversine formula is derived from. To be more accurate, I would need to solve the Euler-Lagrange equation to find the geodesic that the path lies on which would give me a more exact distance. 


## Instructions for how to Run

In order to run this program its quite simple. Be sure that you have cmake downloaded before following these instructions! First open a terminal and type the command `cd build/` (if build doesnt exist issue the command `mkdir build`) Next, you will issue the `cmake ..` command to generate all the cmake commands and files. After that you will enter `make`. And finally you will run `./run_app` to run the interface. You will be prompted with the line "Please Enter a Starting City, or enter Q to quit (must be a US state capital)" for which you will enter the name US State capital city followed by enter, The name is Case sensitive so make sure the first letter is capitalized (and first letter of second name if applicable). If the name is a valid state capital you will be prompted with "Valid Starting Location, Please enter a Destination city" for which you will repeat the same step as the previous one with a different city. If it is a valid city, it will run the algorithm and print out the path from the starting location to the ending location along with the distance in miles traveled. You can check online if these distances are valid for which they are within a few miles. Also note if you check the distances, the distances online will most likely give the distances from airports whereas my program gives distances from the coordinates of the city itself. You will then be prompted with the first prompt and if you wish not to travel again, you must enter "Q" to quit the program. 
